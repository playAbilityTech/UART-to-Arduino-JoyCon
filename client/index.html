<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Serial Arduino Switch Pro Controller</title>
  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js"></script>
  <script>
    document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] +
    ':35729/livereload.js?snipver=1"></' + 'script>')
  </script>
</head>
<body>
  <div id="app">

    <div class="players">
      <a href="/" class="button link"
        v-bind:class="{ active: true }">
        üè†
      </a>
      <a href="/0" class="button link">
        Player 0
      </a>
      <a href="/1" class="button link">
        Player 1
      </a>
      <a href="/2" class="button link">
        Player 2
      </a>
      <a href="/3" class="button link">
        Player 3
      </a>
    </div>

    <div class="outputs">
      <div class="gamepad" v-for="(gamepad, index) in gamepads" :key="index">
        <small>{{portSelected[index]}}</small> / 
        <small>{{joyList[joySelected[index]] && joyList[joySelected[index]].id}}</small><br>
        <p>PLAYER {{index}} - {{gamepad}}</p>

        <input type="checkbox" :id="'checkbox-joy'+index" v-model="useJoystickChecked[index]" @change="checkUseJoy(index)">
        <label :for="'checkbox-joy'+index">Disable IMU Joystick</label>

        <input type="checkbox" :id="'checkbox-pad'+index" v-model="disablePadChecked[index]" @change="checkDisablePad(index)">
        <label :for="'checkbox-pad'+index">Disable PADS</label>

        <input type="checkbox" :id="'checkbox-modifier'+index" v-model="modifiers[index]" @change="setModifier(index, 'LEFT_STICK_X', 'reverse', modifiers[index])">
        <label for="'checkbox-modifier'+index">Reverse Joystick Left X</label>

        <button-gamepad
          class="small"
          :callback="(state) => {
            gamepads[index].mode = (state ? 2 : 1);
            updateGamepad(index);
          }" text="Disable Left Joystick">
        </button-gamepad>

        <button-gamepad
          class="small"
          :callback="(state) => {
            setModifier(index, 'A', 'disable', state);
            }" text="Disable A (hold)">
        </button-gamepad>

        <button-gamepad
          class="small"
          :callback="(state) => {
            setModifier(index, 'A', 'disable', state);
            setModifier(index, 'B', 'hold', state);
            }" text="Break (hold B)">
        </button-gamepad>

        <hr>
        <br>
      </div>
    </div>

    <br><br>

    <ul class="messages" ref="messagesContainer">
      <li class="msg" v-for="(msg, index) in messages" :key="index">
        {{msg}}
        <p>{{ msg.message }}</p>
      </li>
    </ul>
  </div>
</body>

<script>
  var socket = io();
  Vue.component('button-gamepad', {
    data: function () {
      return {
        timer: 0,
        release : null,
        state: 0
      }
    },
    props: {
      'text': String,
      'callback': { type: Function },
    },
    template: `
      <button
        class="button needsclick" type="button"
        @mousedown="buttonClick($event, 1)"
        @mouseup="buttonClick($event, 0)"
        @touchstart="buttonTouch($event, 1)"
        @touchend="buttonTouch($event, 0)">
        {{text}}
      </button>
    `,
    methods: {
      buttonClick(event, state) {
        if (!isTouchDevice) {
          this.buttonState(state);
        }
      },
      buttonTouch(event, state) {
        if (isTouchDevice) {
          this.buttonState(state);
        }
      },
      buttonState(state) {
        if (state == 1) {
          clearTimeout(this.release);
          this.callback(state);
          this.timer = Date.now();
          //console.log('buttonState', state);
        }
        else {
          var diff = Date.now() - this.timer;
          //console.log(diff);
          if (diff > 200) {
            this.callback(state);
            //console.log('buttonState', state);
          }
          else {
            this.release = setTimeout(() => {
              this.callback(state);
              //console.log('buttonState', state);
            }, 200 - diff);
          }
        }
      }
    }
  });
  var app = new Vue({
    el: '#app',
    data: {
      portSelected: [],
      serialChecked: true,
      useJoystickChecked: [],
      useReverseChecked: [],
      disablePadChecked: [],
      options: [],
      messages: [],
      gamepads: [],
      gamepad: {
        button: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        joyLeft: {
          x: 128,
          y: 128,
        },
        joyRight: {
          x: 128,
          y: 128,
        },
        hat: 255,
        mode: 0,
      },
      isTouchDevice: false,
      joyLeftX: 128,
      joyLeftY: 128,
      map: {},
      tcpChecked: true,
      tcpHostIP: '',
      tcpHostPort: '',
      modifiers: [],
      joySelected: [],
      joyList: {},
    },
    created () {
      window.onbeforeunload = () => {
        socket.emit('leave', this.username);
      }
    },
    mounted() {
      isTouchDevice = 'ontouchstart' in document.documentElement;

      socket.on('MESSAGE', (data) => {
        this.messages = data;
      });
      socket.on('PORT_LIST', (obj) => {
        this.options = obj;
        for (var i = 0; i < this.portSelected.length; i++) {
          var exsist = this.options.filter((v) => {
            return Object.values(v).includes(this.portSelected[i]);
          });
          if (!exsist.length) {
            this.portSelected[i] = '';
          }
        }
      });
      socket.on('UPDATE_PORT', (index, port) => {
        console.log("UPDATE_PORT", index, port);
        this.portSelected[index] = port;
      });
      socket.on('JOY_LIST', (obj) => {
        this.joyList = obj;
      });
      socket.on('UPDATE_JOY', (index, joyIndex) => {
        this.joySelected[index] = joyIndex;
      });
      socket.on('GAMEPAD', (index, data) => {
        //console.log("GAMEPAD", index, data);
        this.gamepads[index] = data;
        var mode1 = this.gamepads[index].mode[0] || this.gamepads[index].mode;
        var mode2 = this.gamepads[index].mode[1];
        this.useJoystickChecked[index] = (mode1 == 2);
        this.useReverseChecked[index] = (mode2 == 2);

        this.disablePadChecked[index] = (mode1 == 5);
      });
      socket.on('MAPPING', (data) => {
        this.map = data;
      });

      socket.on('UPDATE_TCP_HOST', (ip, port) => {
        this.tcpHostIP = ip;
        this.tcpHostPort = port;
      });

      socket.on('UPDATE_CONFIG', (config) => {
        this.serialChecked = config.useSerial || false;
        this.tcpChecked = config.useTCP || false;
      });

      if ('addEventListener' in document) {
        document.addEventListener('DOMContentLoaded', function() {
          FastClick.attach(document.body);
        }, false);
      }
    },
    updated() {
      this.$nextTick(() => this.scrollToEnd());
    },

    methods: {
      reloadPortList() {
        socket.emit('GET_PORT_LIST');
      },
      changeSerialPort(e) {
        socket.emit('CHANGE_SERIAL_PORT', this.portSelected);
        if (this.serialChecked) {
          socket.emit('OPEN_SERIAL');
        }
      },
      checkSerial(e) {
        if (this.serialChecked) {
          if (this.portSelected) {
            socket.emit('OPEN_SERIAL');
          }
        }
        else {
          socket.emit('CLOSE_SERIAL');
        }
      },
      checkTCP(e) {
        if (this.tcpChecked) {
          if (this.tcpHostIP) {
            socket.emit('OPEN_TCP');
          }
        }
        else {
          socket.emit('CLOSE_TCP');
        }
      },
      changeTcpHost(e) {
        if (this.tcpHostIP && this.tcpHostPort) {
          socket.emit('CHANGE_TCP_HOST', this.tcpHostIP, this.tcpHostPort);

          if (this.tcpChecked) {
            socket.emit('OPEN_TCP');
          }
        }
        e.preventDefault();
      },
      checkUseJoy(index) {
        if (this.useJoystickChecked[index]) {
          this.gamepads[index].mode = 2;
        }
        else {
          this.gamepads[index].mode = 1;
        }
        this.updateGamepad(index);
      },
      checkDisablePad(index) {
        if (this.disablePadChecked[index]) {
          this.gamepads[index].mode = 5;
        }
        else {
          this.gamepads[index].mode = 1;
        }
        this.updateGamepad(index);
      },
      setModifier(index, key, modifier, value) {
        socket.emit('SET_MODIFIER', index, {
          modifier: modifier,
          value: value,
          key: key
        });
      },
      scrollToEnd() {
        var content = this.$refs.messagesContainer;
        content.scrollTop = content.scrollHeight;
      },
      updateGamepad(index) {
        console.log("updateGamepad", index, this.gamepads[index].joyRight);
        socket.emit('UPDATE_GAMEPAD', index, this.gamepads[index]);
      }
    }
  })
</script>

<style lang="scss" scoped>
  html, body {
    margin: 0; padding: 0;
    font-family: Helvetica, Arial, sans-serif;
  }

  *, *:before, *:after {
    box-sizing: border-box;
  }

  #app {
    height: 100vh;
    padding: 10px;
    display: flex;
    flex-direction: column;
  }

  .top {
    display: block;
  }

  #serialPort {
    width: 300px;
  }

  .messages {
    flex: 1;
    min-height: 200px;
    margin: 10px 0 0;
    overflow-y: auto;
    overflow-x: auto;
    padding: 10px 10px 0;
    border: 1px solid black;
    list-style: none;
    font-size: 13px;
    font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
    white-space: nowrap;
    line-height: .5em;
  }

  .button {
    position: relative;
    min-width: 46px;
    height: 46px;
    margin-right: 10px;
    margin-bottom: 10px;
    user-select: none;
    border-radius: 23px;
    color: black;
    border: 2px solid #403e41;
    font-size: 16px;
    padding: 0 5px;
    box-shadow: 0 3px #403e41;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  .button:focus {
    outline: none;
  }

  .button:active,
  .button.active {
    top: 3px;
    box-shadow: 0 0px #403e41;
  }

  .button.small {
    display: inline-block;
    padding: 7px 15px;
    text-decoration: none;
    height: 32px;
    vertical-align: middle;
    line-height: 1em;
  }

  .players {
    text-align: center;
    margin: 10px 0 30px;
  }
    .players .button {
      display: inline-block;
      padding: 7px 15px;
      text-decoration: none;
      height: 32px;
      vertical-align: middle;
      line-height: 1em;
    }

  .controls {
    padding: 10px;
    display: flex;
  }

  .controls-left {
    width: 50%;
  }
  .controls-right {
    width: 50%;
    text-align: right;
  }

  .hat {
    display: inline-block;
    margin: 10px 0;
  }

  .hat .button {
    margin: 0;
  }

  .hat table {
    border-collapse: collapse;
    border-spacing: 0;
    text-align: center;
  }

</style>

</html>